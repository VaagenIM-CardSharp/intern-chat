<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>Socket.IO chat</title>
    <link rel="stylesheet" href="/main.css" />
  </head>
  <body>
    <div id="nickname-area">
      <form id="nickname-form" action="">
        <label for="nickname">Enter nickname:</label>
        <input id="nickname" autocomplete="off" maxlength="32" />
        <button type="submit">Save</button>
      </form>
      <div id="nickname-display" class="hidden"></div>
    </div>
    <ul id="messages"></ul>
    <div
      id="message-limit-warning"
      class="limit-warning hidden"
      role="alert"
      aria-live="assertive"
    ></div>
    <form id="form" action="">
      <input id="input" autocomplete="off" /><button>Send</button>
    </form>
    <script src="/socket.io/socket.io.js"></script>
    <script>
  let counter = 0;
  const MAX_MESSAGES = 500;
  const DEFAULT_MAX_MESSAGE_LENGTH = 500;
  let nickname = '';
  let activeMaxMessageLength = DEFAULT_MAX_MESSAGE_LENGTH;

  const socket = io({
    ackTimeout: 10000,
    retries: 3,
    auth: {
      serverOffset: 0
    }
  });

  const form = document.getElementById('form');
  const input = document.getElementById('input');
  const messages = document.getElementById('messages');
  const nicknameForm = document.getElementById('nickname-form');
  const nicknameInput = document.getElementById('nickname');
  const nicknameDisplay = document.getElementById('nickname-display');
  const sendButton = form?.querySelector('button');
  const limitWarning = document.getElementById('message-limit-warning');

  const getMaxMessageLength = () => activeMaxMessageLength;

  const formatLimitMessage = (limit) =>
    `Message cannot exceed ${limit} characters.`;

  const setLimitWarning = (message = '') => {
    if (!limitWarning) {
      return;
    }

    if (message) {
      limitWarning.textContent = message;
      limitWarning.classList.remove('hidden');
    } else {
      limitWarning.textContent = '';
      limitWarning.classList.add('hidden');
    }
  };

  const updateMessageValidity = (value = '') => {
    if (!input) {
      return;
    }

    const limit = getMaxMessageLength();
    const message = formatLimitMessage(limit);
    const isTooLong = value.length > limit;

    if (isTooLong) {
      input.setCustomValidity(message);
      setLimitWarning(message);
    } else {
      input.setCustomValidity('');
      setLimitWarning('');
    }
  };

  const setMaxMessageLength = (value) => {
    if (!Number.isInteger(value) || value <= 0) {
      return;
    }

    if (value === activeMaxMessageLength) {
      return;
    }

    activeMaxMessageLength = value;
    updateMessageValidity(input?.value ?? '');
  };

  if (input) {
    input.addEventListener('input', () => updateMessageValidity(input.value));
    updateMessageValidity(input.value);
  }

  const toggleChatControls = (enabled) => {
    if (input) {
      input.disabled = !enabled;
    }

    if (sendButton) {
      sendButton.disabled = !enabled;
    }
  };

  toggleChatControls(false);

  const appendMessage = (content) => {
    const item = document.createElement('li');
    item.textContent = content;
    messages.appendChild(item);

    while (messages.children.length > MAX_MESSAGES) {
      messages.removeChild(messages.firstChild);
    }

    window.scrollTo(0, document.body.scrollHeight);
  };

  if (nicknameForm) {
    nicknameForm.addEventListener('submit', (event) => {
      event.preventDefault();

      const value = nicknameInput.value.trim();
      if (!value) {
        nicknameInput.focus();
        return;
      }

      nickname = value;
      toggleChatControls(true);
      nicknameForm.classList.add('hidden');

      if (nicknameDisplay) {
        nicknameDisplay.textContent = `Your nickname: ${nickname}`;
        nicknameDisplay.classList.remove('hidden');
      }

      if (input) {
        input.focus();
      }
    });
  }

  form.addEventListener('submit', (e) => {
    e.preventDefault();

    if (!nickname) {
      if (nicknameInput) {
        nicknameInput.focus();
      }
      return;
    }

    if (!input) {
      return;
    }

    if (input.value.length > getMaxMessageLength()) {
      updateMessageValidity(input.value);
      input.reportValidity();
      return;
    }

    const text = input.value.trim();
    if (!text) {
      return;
    }

    const clientOffset = `${socket.id}-${counter++}`;
    socket.emit(
      'chat message',
      `${nickname}: ${text}`,
      clientOffset,
      (ack = {}) => {
        if (!ack.ok) {
          if (ack.error === 'MESSAGE_TOO_LONG') {
            const fallbackLimit = getMaxMessageLength();
            const limit =
              typeof ack.limit === 'number' && ack.limit > 0
                ? ack.limit
                : fallbackLimit;

            if (limit !== fallbackLimit) {
              setMaxMessageLength(limit);
            }

            const message = formatLimitMessage(limit);
            setLimitWarning(message);

            if (input) {
              input.setCustomValidity(message);
              input.reportValidity();
            }
          }

          console.error('Message acknowledgement failed', ack);
          return;
        }

        if (typeof ack.serverOffset === 'number') {
          socket.auth.serverOffset = ack.serverOffset;
        }
      }
    );

    input.value = '';
    updateMessageValidity('');
  });

  socket.on('chat message', (payload) => {
    if (!payload || typeof payload !== 'object') {
      return;
    }

    const { id, content } = payload;
    if (typeof content !== 'string') {
      return;
    }

    appendMessage(content);

    if (typeof id === 'number') {
      socket.auth.serverOffset = id;
    }
  });

  socket.on('config', (payload) => {
    if (!payload || typeof payload !== 'object') {
      return;
    }

    const { maxMessageLength } = payload;
    if (Number.isInteger(maxMessageLength) && maxMessageLength > 0) {
      setMaxMessageLength(maxMessageLength);
    }
  });
</script>

  </body>
</html>
